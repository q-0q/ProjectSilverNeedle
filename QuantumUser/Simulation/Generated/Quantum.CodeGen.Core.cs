// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum AELayer : int {
    Back,
    Middle,
    Front,
  }
  public enum GameEventType : int {
    Counter,
    Punish,
    Knockdown,
  }
  public enum TrajectoryDashType : int {
    None,
    Forward,
    Backward,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    L = 1 << 0,
    M = 1 << 1,
    H = 1 << 2,
    S = 1 << 3,
    T = 1 << 4,
    Jump = 1 << 5,
    Dash = 1 << 6,
    Backdash = 1 << 7,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 100;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(52)]
    public Button L;
    [FieldOffset(64)]
    public Button M;
    [FieldOffset(28)]
    public Button H;
    [FieldOffset(76)]
    public Button S;
    [FieldOffset(88)]
    public Button T;
    [FieldOffset(40)]
    public Button Jump;
    [FieldOffset(16)]
    public Button Dash;
    [FieldOffset(4)]
    public Button Backdash;
    [FieldOffset(0)]
    public Int32 UnflippedNumpadDirection;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + L.GetHashCode();
        hash = hash * 31 + M.GetHashCode();
        hash = hash * 31 + H.GetHashCode();
        hash = hash * 31 + S.GetHashCode();
        hash = hash * 31 + T.GetHashCode();
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Backdash.GetHashCode();
        hash = hash * 31 + UnflippedNumpadDirection.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.L: return L.IsDown;
        case InputButtons.M: return M.IsDown;
        case InputButtons.H: return H.IsDown;
        case InputButtons.S: return S.IsDown;
        case InputButtons.T: return T.IsDown;
        case InputButtons.Jump: return Jump.IsDown;
        case InputButtons.Dash: return Dash.IsDown;
        case InputButtons.Backdash: return Backdash.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.L: return L.WasPressed;
        case InputButtons.M: return M.WasPressed;
        case InputButtons.H: return H.WasPressed;
        case InputButtons.S: return S.WasPressed;
        case InputButtons.T: return T.WasPressed;
        case InputButtons.Jump: return Jump.WasPressed;
        case InputButtons.Dash: return Dash.WasPressed;
        case InputButtons.Backdash: return Backdash.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->UnflippedNumpadDirection);
        Button.Serialize(&p->Backdash, serializer);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->H, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->L, serializer);
        Button.Serialize(&p->M, serializer);
        Button.Serialize(&p->S, serializer);
        Button.Serialize(&p->T, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1152;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(120)]
    public BitSet1024 Systems;
    [FieldOffset(248)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(536)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(540)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[600];
    [FieldOffset(1144)]
    public BitSet6 PlayerLastConnectionState;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 100, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AnimationData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 frame;
    [FieldOffset(4)]
    public Int32 path;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 103;
        hash = hash * 31 + frame.GetHashCode();
        hash = hash * 31 + path.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimationData*)ptr;
        serializer.Stream.Serialize(&p->frame);
        serializer.Stream.Serialize(&p->path);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AnimationEntityData : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(12)]
    public Int32 type;
    [FieldOffset(4)]
    public Int32 framesAlive;
    [FieldOffset(8)]
    public Int32 spriteId;
    [FieldOffset(16)]
    public QBoolean flip;
    [FieldOffset(24)]
    public FP angle;
    [FieldOffset(0)]
    public AELayer layer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4969;
        hash = hash * 31 + type.GetHashCode();
        hash = hash * 31 + framesAlive.GetHashCode();
        hash = hash * 31 + spriteId.GetHashCode();
        hash = hash * 31 + flip.GetHashCode();
        hash = hash * 31 + angle.GetHashCode();
        hash = hash * 31 + (Int32)layer;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimationEntityData*)ptr;
        serializer.Stream.Serialize((Int32*)&p->layer);
        serializer.Stream.Serialize(&p->framesAlive);
        serializer.Stream.Serialize(&p->spriteId);
        serializer.Stream.Serialize(&p->type);
        QBoolean.Serialize(&p->flip, serializer);
        FP.Serialize(&p->angle, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CollisionBoxDatax : Quantum.IComponent {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    public EntityRef source;
    [FieldOffset(16)]
    public Int32 type;
    [FieldOffset(12)]
    public Int32 subtype;
    [FieldOffset(120)]
    public FP width;
    [FieldOffset(80)]
    public FP height;
    [FieldOffset(8)]
    public Int32 level;
    [FieldOffset(4)]
    public Int32 bonusHitStun;
    [FieldOffset(0)]
    public Int32 bonusBlockStun;
    [FieldOffset(48)]
    public FP blockPushback;
    [FieldOffset(88)]
    public FP hitPushback;
    [FieldOffset(112)]
    public FP visualAngle;
    [FieldOffset(96)]
    public FP trajectoryHeight;
    [FieldOffset(104)]
    public FP trajectoryXVelocity;
    [FieldOffset(72)]
    public FP gravityScaling;
    [FieldOffset(64)]
    public FP damageScaling;
    [FieldOffset(56)]
    public FP damage;
    [FieldOffset(28)]
    public QBoolean launches;
    [FieldOffset(24)]
    public QBoolean hardKnockdown;
    [FieldOffset(20)]
    public QBoolean groundBounce;
    [FieldOffset(32)]
    public QBoolean wallBounce;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9697;
        hash = hash * 31 + source.GetHashCode();
        hash = hash * 31 + type.GetHashCode();
        hash = hash * 31 + subtype.GetHashCode();
        hash = hash * 31 + width.GetHashCode();
        hash = hash * 31 + height.GetHashCode();
        hash = hash * 31 + level.GetHashCode();
        hash = hash * 31 + bonusHitStun.GetHashCode();
        hash = hash * 31 + bonusBlockStun.GetHashCode();
        hash = hash * 31 + blockPushback.GetHashCode();
        hash = hash * 31 + hitPushback.GetHashCode();
        hash = hash * 31 + visualAngle.GetHashCode();
        hash = hash * 31 + trajectoryHeight.GetHashCode();
        hash = hash * 31 + trajectoryXVelocity.GetHashCode();
        hash = hash * 31 + gravityScaling.GetHashCode();
        hash = hash * 31 + damageScaling.GetHashCode();
        hash = hash * 31 + damage.GetHashCode();
        hash = hash * 31 + launches.GetHashCode();
        hash = hash * 31 + hardKnockdown.GetHashCode();
        hash = hash * 31 + groundBounce.GetHashCode();
        hash = hash * 31 + wallBounce.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CollisionBoxDatax*)ptr;
        serializer.Stream.Serialize(&p->bonusBlockStun);
        serializer.Stream.Serialize(&p->bonusHitStun);
        serializer.Stream.Serialize(&p->level);
        serializer.Stream.Serialize(&p->subtype);
        serializer.Stream.Serialize(&p->type);
        QBoolean.Serialize(&p->groundBounce, serializer);
        QBoolean.Serialize(&p->hardKnockdown, serializer);
        QBoolean.Serialize(&p->launches, serializer);
        QBoolean.Serialize(&p->wallBounce, serializer);
        EntityRef.Serialize(&p->source, serializer);
        FP.Serialize(&p->blockPushback, serializer);
        FP.Serialize(&p->damage, serializer);
        FP.Serialize(&p->damageScaling, serializer);
        FP.Serialize(&p->gravityScaling, serializer);
        FP.Serialize(&p->height, serializer);
        FP.Serialize(&p->hitPushback, serializer);
        FP.Serialize(&p->trajectoryHeight, serializer);
        FP.Serialize(&p->trajectoryXVelocity, serializer);
        FP.Serialize(&p->visualAngle, serializer);
        FP.Serialize(&p->width, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ComboData : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 length;
    [FieldOffset(4)]
    public QDictionaryPtr<Int32, Int32> hitCounts;
    [FieldOffset(16)]
    public FP gravityScaling;
    [FieldOffset(8)]
    public FP damageScaling;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13171;
        hash = hash * 31 + length.GetHashCode();
        hash = hash * 31 + hitCounts.GetHashCode();
        hash = hash * 31 + gravityScaling.GetHashCode();
        hash = hash * 31 + damageScaling.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      hitCounts = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.ComboData*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ComboData*)ptr;
        serializer.Stream.Serialize(&p->length);
        QDictionary.Serialize(&p->hitCounts, serializer, Statics.SerializeInt32, Statics.SerializeInt32);
        FP.Serialize(&p->damageScaling, serializer);
        FP.Serialize(&p->gravityScaling, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CpuControllerData : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(12)]
    public QBoolean cpuEnabled;
    [FieldOffset(28)]
    public QBoolean forceCounter;
    [FieldOffset(20)]
    public QBoolean doAction;
    [FieldOffset(24)]
    public QBoolean doJump;
    [FieldOffset(8)]
    public QBoolean block;
    [FieldOffset(16)]
    public QBoolean dash;
    [FieldOffset(4)]
    public Int32 inputType;
    [FieldOffset(0)]
    public Int32 commandDirection;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14533;
        hash = hash * 31 + cpuEnabled.GetHashCode();
        hash = hash * 31 + forceCounter.GetHashCode();
        hash = hash * 31 + doAction.GetHashCode();
        hash = hash * 31 + doJump.GetHashCode();
        hash = hash * 31 + block.GetHashCode();
        hash = hash * 31 + dash.GetHashCode();
        hash = hash * 31 + inputType.GetHashCode();
        hash = hash * 31 + commandDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CpuControllerData*)ptr;
        serializer.Stream.Serialize(&p->commandDirection);
        serializer.Stream.Serialize(&p->inputType);
        QBoolean.Serialize(&p->block, serializer);
        QBoolean.Serialize(&p->cpuEnabled, serializer);
        QBoolean.Serialize(&p->dash, serializer);
        QBoolean.Serialize(&p->doAction, serializer);
        QBoolean.Serialize(&p->doJump, serializer);
        QBoolean.Serialize(&p->forceCounter, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CutsceneData : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef initiator;
    [FieldOffset(4)]
    public QBoolean initiatorFacingRight;
    [FieldOffset(0)]
    public Int32 cutsceneIndex;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18049;
        hash = hash * 31 + initiator.GetHashCode();
        hash = hash * 31 + initiatorFacingRight.GetHashCode();
        hash = hash * 31 + cutsceneIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CutsceneData*)ptr;
        serializer.Stream.Serialize(&p->cutsceneIndex);
        QBoolean.Serialize(&p->initiatorFacingRight, serializer);
        EntityRef.Serialize(&p->initiator, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct DramaticData : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 remaining;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13127;
        hash = hash * 31 + remaining.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DramaticData*)ptr;
        serializer.Stream.Serialize(&p->remaining);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FSMData : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public Int32 currentState;
    [FieldOffset(12)]
    public Int32 framesInState;
    [FieldOffset(24)]
    public FP virtualTimeInState;
    [FieldOffset(4)]
    public Int32 currentCollisionState;
    [FieldOffset(0)]
    public Int32 collisionFramesInState;
    [FieldOffset(16)]
    public Int32 test;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8647;
        hash = hash * 31 + currentState.GetHashCode();
        hash = hash * 31 + framesInState.GetHashCode();
        hash = hash * 31 + virtualTimeInState.GetHashCode();
        hash = hash * 31 + currentCollisionState.GetHashCode();
        hash = hash * 31 + collisionFramesInState.GetHashCode();
        hash = hash * 31 + test.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FSMData*)ptr;
        serializer.Stream.Serialize(&p->collisionFramesInState);
        serializer.Stream.Serialize(&p->currentCollisionState);
        serializer.Stream.Serialize(&p->currentState);
        serializer.Stream.Serialize(&p->framesInState);
        serializer.Stream.Serialize(&p->test);
        FP.Serialize(&p->virtualTimeInState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FrameMeterData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public QListPtr<Int32> types;
    [FieldOffset(0)]
    public QListPtr<Int32> frames;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 659;
        hash = hash * 31 + types.GetHashCode();
        hash = hash * 31 + frames.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      types = default;
      frames = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.FrameMeterData*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FrameMeterData*)ptr;
        QList.Serialize(&p->frames, serializer, Statics.SerializeInt32);
        QList.Serialize(&p->types, serializer, Statics.SerializeInt32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameFSMData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 currentState;
    [FieldOffset(4)]
    public Int32 framesInState;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12119;
        hash = hash * 31 + currentState.GetHashCode();
        hash = hash * 31 + framesInState.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameFSMData*)ptr;
        serializer.Stream.Serialize(&p->currentState);
        serializer.Stream.Serialize(&p->framesInState);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HealthData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP health;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4673;
        hash = hash * 31 + health.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HealthData*)ptr;
        FP.Serialize(&p->health, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HitEntitiesTracker : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<EntityRef> HitEntities;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16829;
        hash = hash * 31 + HitEntities.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      HitEntities = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.HitEntitiesTracker*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HitEntitiesTracker*)ptr;
        QList.Serialize(&p->HitEntities, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HitstopData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 hitstopRemaining;
    [FieldOffset(4)]
    public QBoolean queued;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18133;
        hash = hash * 31 + hitstopRemaining.GetHashCode();
        hash = hash * 31 + queued.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HitstopData*)ptr;
        serializer.Stream.Serialize(&p->hitstopRemaining);
        QBoolean.Serialize(&p->queued, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InputBuffer : Quantum.IComponent {
    public const Int32 SIZE = 12;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public Int32 length;
    [FieldOffset(8)]
    public Int32 type;
    [FieldOffset(0)]
    public Int32 direction;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3637;
        hash = hash * 31 + length.GetHashCode();
        hash = hash * 31 + type.GetHashCode();
        hash = hash * 31 + direction.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InputBuffer*)ptr;
        serializer.Stream.Serialize(&p->direction);
        serializer.Stream.Serialize(&p->length);
        serializer.Stream.Serialize(&p->type);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct InteractionControllerData : Quantum.IComponent {
    public const Int32 SIZE = 28;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(8)]
    public Int32 player0InputType;
    [FieldOffset(0)]
    public Int32 player0CommandDirection;
    [FieldOffset(4)]
    public Int32 player0Frame;
    [FieldOffset(20)]
    public Int32 player1InputType;
    [FieldOffset(12)]
    public Int32 player1CommandDirection;
    [FieldOffset(16)]
    public Int32 player1Frame;
    [FieldOffset(24)]
    public QBoolean enabled;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4027;
        hash = hash * 31 + player0InputType.GetHashCode();
        hash = hash * 31 + player0CommandDirection.GetHashCode();
        hash = hash * 31 + player0Frame.GetHashCode();
        hash = hash * 31 + player1InputType.GetHashCode();
        hash = hash * 31 + player1CommandDirection.GetHashCode();
        hash = hash * 31 + player1Frame.GetHashCode();
        hash = hash * 31 + enabled.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (InteractionControllerData*)ptr;
        serializer.Stream.Serialize(&p->player0CommandDirection);
        serializer.Stream.Serialize(&p->player0Frame);
        serializer.Stream.Serialize(&p->player0InputType);
        serializer.Stream.Serialize(&p->player1CommandDirection);
        serializer.Stream.Serialize(&p->player1Frame);
        serializer.Stream.Serialize(&p->player1InputType);
        QBoolean.Serialize(&p->enabled, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KinematicsData : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FPVector2 attachPosition;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3461;
        hash = hash * 31 + attachPosition.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KinematicsData*)ptr;
        FPVector2.Serialize(&p->attachPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MomentumData : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP virtualTimeInMomentum;
    [FieldOffset(0)]
    public Int32 framesInMomentum;
    [FieldOffset(8)]
    public FP momentumAmount;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13469;
        hash = hash * 31 + virtualTimeInMomentum.GetHashCode();
        hash = hash * 31 + framesInMomentum.GetHashCode();
        hash = hash * 31 + momentumAmount.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MomentumData*)ptr;
        serializer.Stream.Serialize(&p->framesInMomentum);
        FP.Serialize(&p->momentumAmount, serializer);
        FP.Serialize(&p->virtualTimeInMomentum, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerDirection : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QBoolean FacingRight;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4637;
        hash = hash * 31 + FacingRight.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerDirection*)ptr;
        QBoolean.Serialize(&p->FacingRight, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public PlayerRef Player;
    [FieldOffset(0)]
    public Int32 characterId;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + characterId.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        serializer.Stream.Serialize(&p->characterId);
        PlayerRef.Serialize(&p->Player, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ProtectionData : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP virtualTimeSinceThrowProtectionStart;
    [FieldOffset(0)]
    public FP virtualTimeSinceCrossupProtectionStart;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13249;
        hash = hash * 31 + virtualTimeSinceThrowProtectionStart.GetHashCode();
        hash = hash * 31 + virtualTimeSinceCrossupProtectionStart.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ProtectionData*)ptr;
        FP.Serialize(&p->virtualTimeSinceCrossupProtectionStart, serializer);
        FP.Serialize(&p->virtualTimeSinceThrowProtectionStart, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PushbackData : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP virtualTimeInPushback;
    [FieldOffset(0)]
    public Int32 framesInPushback;
    [FieldOffset(8)]
    public FP pushbackAmount;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21101;
        hash = hash * 31 + virtualTimeInPushback.GetHashCode();
        hash = hash * 31 + framesInPushback.GetHashCode();
        hash = hash * 31 + pushbackAmount.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PushbackData*)ptr;
        serializer.Stream.Serialize(&p->framesInPushback);
        FP.Serialize(&p->pushbackAmount, serializer);
        FP.Serialize(&p->virtualTimeInPushback, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ScoreData : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 score;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8101;
        hash = hash * 31 + score.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ScoreData*)ptr;
        serializer.Stream.Serialize(&p->score);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SlowdownData : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 slowdownRemaining;
    [FieldOffset(8)]
    public FP multiplier;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6131;
        hash = hash * 31 + slowdownRemaining.GetHashCode();
        hash = hash * 31 + multiplier.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SlowdownData*)ptr;
        serializer.Stream.Serialize(&p->slowdownRemaining);
        FP.Serialize(&p->multiplier, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StunData : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 stun;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13217;
        hash = hash * 31 + stun.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StunData*)ptr;
        serializer.Stream.Serialize(&p->stun);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SummonData : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef owner;
    [FieldOffset(4)]
    public PlayerRef player;
    [FieldOffset(0)]
    public Int32 counter;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4903;
        hash = hash * 31 + owner.GetHashCode();
        hash = hash * 31 + player.GetHashCode();
        hash = hash * 31 + counter.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SummonData*)ptr;
        serializer.Stream.Serialize(&p->counter);
        PlayerRef.Serialize(&p->player, serializer);
        EntityRef.Serialize(&p->owner, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TrajectoryData : Quantum.IComponent {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public Int32 jumpsRemaining;
    [FieldOffset(0)]
    public Int32 framesInTrajectory;
    [FieldOffset(64)]
    public FP virtualTimeInTrajectory;
    [FieldOffset(72)]
    public FP xVelocity;
    [FieldOffset(48)]
    public FP startingTrajectoryHeight;
    [FieldOffset(56)]
    public FP trajectoryHeight;
    [FieldOffset(12)]
    public Int32 timeToTrajectoryHeight;
    [FieldOffset(40)]
    public FP fallSpeed;
    [FieldOffset(8)]
    public Int32 timeToFallSpeed;
    [FieldOffset(24)]
    public QBoolean hardKnockdown;
    [FieldOffset(16)]
    public QBoolean empty;
    [FieldOffset(20)]
    public QBoolean groundBounce;
    [FieldOffset(28)]
    public QBoolean wallBounce;
    [FieldOffset(32)]
    public TrajectoryDashType dashType;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5323;
        hash = hash * 31 + jumpsRemaining.GetHashCode();
        hash = hash * 31 + framesInTrajectory.GetHashCode();
        hash = hash * 31 + virtualTimeInTrajectory.GetHashCode();
        hash = hash * 31 + xVelocity.GetHashCode();
        hash = hash * 31 + startingTrajectoryHeight.GetHashCode();
        hash = hash * 31 + trajectoryHeight.GetHashCode();
        hash = hash * 31 + timeToTrajectoryHeight.GetHashCode();
        hash = hash * 31 + fallSpeed.GetHashCode();
        hash = hash * 31 + timeToFallSpeed.GetHashCode();
        hash = hash * 31 + hardKnockdown.GetHashCode();
        hash = hash * 31 + empty.GetHashCode();
        hash = hash * 31 + groundBounce.GetHashCode();
        hash = hash * 31 + wallBounce.GetHashCode();
        hash = hash * 31 + (Int32)dashType;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TrajectoryData*)ptr;
        serializer.Stream.Serialize(&p->framesInTrajectory);
        serializer.Stream.Serialize(&p->jumpsRemaining);
        serializer.Stream.Serialize(&p->timeToFallSpeed);
        serializer.Stream.Serialize(&p->timeToTrajectoryHeight);
        QBoolean.Serialize(&p->empty, serializer);
        QBoolean.Serialize(&p->groundBounce, serializer);
        QBoolean.Serialize(&p->hardKnockdown, serializer);
        QBoolean.Serialize(&p->wallBounce, serializer);
        serializer.Stream.Serialize((Int32*)&p->dashType);
        FP.Serialize(&p->fallSpeed, serializer);
        FP.Serialize(&p->startingTrajectoryHeight, serializer);
        FP.Serialize(&p->trajectoryHeight, serializer);
        FP.Serialize(&p->virtualTimeInTrajectory, serializer);
        FP.Serialize(&p->xVelocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WhiffData : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QBoolean whiffed;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1663;
        hash = hash * 31 + whiffed.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WhiffData*)ptr;
        QBoolean.Serialize(&p->whiffed, serializer);
    }
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AnimationData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AnimationData>();
      BuildSignalsArrayOnComponentAdded<Quantum.AnimationEntityData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AnimationEntityData>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.CollisionBoxDatax>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CollisionBoxDatax>();
      BuildSignalsArrayOnComponentAdded<Quantum.ComboData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ComboData>();
      BuildSignalsArrayOnComponentAdded<Quantum.CpuControllerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CpuControllerData>();
      BuildSignalsArrayOnComponentAdded<Quantum.CutsceneData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CutsceneData>();
      BuildSignalsArrayOnComponentAdded<Quantum.DramaticData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.DramaticData>();
      BuildSignalsArrayOnComponentAdded<Quantum.FSMData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.FSMData>();
      BuildSignalsArrayOnComponentAdded<Quantum.FrameMeterData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.FrameMeterData>();
      BuildSignalsArrayOnComponentAdded<Quantum.GameFSMData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GameFSMData>();
      BuildSignalsArrayOnComponentAdded<Quantum.HealthData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HealthData>();
      BuildSignalsArrayOnComponentAdded<Quantum.HitEntitiesTracker>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HitEntitiesTracker>();
      BuildSignalsArrayOnComponentAdded<Quantum.HitstopData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HitstopData>();
      BuildSignalsArrayOnComponentAdded<Quantum.InputBuffer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InputBuffer>();
      BuildSignalsArrayOnComponentAdded<Quantum.InteractionControllerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.InteractionControllerData>();
      BuildSignalsArrayOnComponentAdded<Quantum.KinematicsData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KinematicsData>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.MomentumData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MomentumData>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerDirection>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerDirection>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.ProtectionData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ProtectionData>();
      BuildSignalsArrayOnComponentAdded<Quantum.PushbackData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PushbackData>();
      BuildSignalsArrayOnComponentAdded<Quantum.ScoreData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ScoreData>();
      BuildSignalsArrayOnComponentAdded<Quantum.SlowdownData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SlowdownData>();
      BuildSignalsArrayOnComponentAdded<Quantum.StunData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.StunData>();
      BuildSignalsArrayOnComponentAdded<Quantum.SummonData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SummonData>();
      BuildSignalsArrayOnComponentAdded<Quantum.TrajectoryData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TrajectoryData>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.WhiffData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.WhiffData>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->L = i->L.Update(this.Number, input.L);
      i->M = i->M.Update(this.Number, input.M);
      i->H = i->H.Update(this.Number, input.H);
      i->S = i->S.Update(this.Number, input.S);
      i->T = i->T.Update(this.Number, input.T);
      i->Jump = i->Jump.Update(this.Number, input.Jump);
      i->Dash = i->Dash.Update(this.Number, input.Dash);
      i->Backdash = i->Backdash.Update(this.Number, input.Backdash);
      i->UnflippedNumpadDirection = input.UnflippedNumpadDirection;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeEntityRef = EntityRef.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.AELayer), 4);
      typeRegistry.Register(typeof(Quantum.AnimationData), Quantum.AnimationData.SIZE);
      typeRegistry.Register(typeof(Quantum.AnimationEntityData), Quantum.AnimationEntityData.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.CollisionBoxDatax), Quantum.CollisionBoxDatax.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(Quantum.ComboData), Quantum.ComboData.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CpuControllerData), Quantum.CpuControllerData.SIZE);
      typeRegistry.Register(typeof(Quantum.CutsceneData), Quantum.CutsceneData.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.DramaticData), Quantum.DramaticData.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(Quantum.FSMData), Quantum.FSMData.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(Quantum.FrameMeterData), Quantum.FrameMeterData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameEventType), 4);
      typeRegistry.Register(typeof(Quantum.GameFSMData), Quantum.GameFSMData.SIZE);
      typeRegistry.Register(typeof(Quantum.HealthData), Quantum.HealthData.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.HitEntitiesTracker), Quantum.HitEntitiesTracker.SIZE);
      typeRegistry.Register(typeof(Quantum.HitstopData), Quantum.HitstopData.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputBuffer), Quantum.InputBuffer.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(Quantum.InteractionControllerData), Quantum.InteractionControllerData.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KinematicsData), Quantum.KinematicsData.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.MomentumData), Quantum.MomentumData.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerDirection), Quantum.PlayerDirection.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.ProtectionData), Quantum.ProtectionData.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(Quantum.PushbackData), Quantum.PushbackData.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Quantum.ScoreData), Quantum.ScoreData.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SlowdownData), Quantum.SlowdownData.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.StunData), Quantum.StunData.SIZE);
      typeRegistry.Register(typeof(Quantum.SummonData), Quantum.SummonData.SIZE);
      typeRegistry.Register(typeof(Quantum.TrajectoryDashType), 4);
      typeRegistry.Register(typeof(Quantum.TrajectoryData), Quantum.TrajectoryData.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.WhiffData), Quantum.WhiffData.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 27)
        .AddBuiltInComponents()
        .Add<Quantum.AnimationData>(Quantum.AnimationData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.AnimationEntityData>(Quantum.AnimationEntityData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CollisionBoxDatax>(Quantum.CollisionBoxDatax.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ComboData>(Quantum.ComboData.Serialize, null, Quantum.ComboData.OnRemoved, ComponentFlags.None)
        .Add<Quantum.CpuControllerData>(Quantum.CpuControllerData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CutsceneData>(Quantum.CutsceneData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.DramaticData>(Quantum.DramaticData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.FSMData>(Quantum.FSMData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.FrameMeterData>(Quantum.FrameMeterData.Serialize, null, Quantum.FrameMeterData.OnRemoved, ComponentFlags.None)
        .Add<Quantum.GameFSMData>(Quantum.GameFSMData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.HealthData>(Quantum.HealthData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.HitEntitiesTracker>(Quantum.HitEntitiesTracker.Serialize, null, Quantum.HitEntitiesTracker.OnRemoved, ComponentFlags.None)
        .Add<Quantum.HitstopData>(Quantum.HitstopData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InputBuffer>(Quantum.InputBuffer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.InteractionControllerData>(Quantum.InteractionControllerData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KinematicsData>(Quantum.KinematicsData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MomentumData>(Quantum.MomentumData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerDirection>(Quantum.PlayerDirection.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ProtectionData>(Quantum.ProtectionData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PushbackData>(Quantum.PushbackData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ScoreData>(Quantum.ScoreData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SlowdownData>(Quantum.SlowdownData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.StunData>(Quantum.StunData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SummonData>(Quantum.SummonData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TrajectoryData>(Quantum.TrajectoryData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.WhiffData>(Quantum.WhiffData.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AELayer>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameEventType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.TrajectoryDashType>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
